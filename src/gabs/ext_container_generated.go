// Code generated by "ext_gen.go ; DO NOT EDIT.
package gabs
import(
"fmt"
)


func (g *Container) MustGetInt(path ...string)(int ){
	if s,e:=g.GetInt(path ...);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetInt(path ...string)(int,error ){
	
    if g.Exists(path...) {
      if d, ok := g.S(path...).Data().(int); ok {
        return d,nil
      }else if d,ok:=g.S(path...).Data().(float64);ok {
      		return int(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want int|float64 got %T ",g.S(path...).Data())
    }
    return 0,ErrInvalidPath
  }
func (g *Container) MustGetIntP(path string)(int ){
	if s,e:=g.GetIntP(path);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetIntP(path string) (int ,error ) {
	
    if g.ExistsP(path) {
      if d, ok := g.Path(path).Data().(int); ok {
        return d,nil
      }else if d,ok:=g.Path(path).Data().(float64); ok {
      		return int(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want int|float64 got %T ",g.Path(path).Data())
    }
    return 0,ErrInvalidPath
}
func (g *Container) MustGetIntSlice(path ...string)([]int){
	if s,e:=g.GetIntSlice(path...);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetIntSlice(path ...string) ([]int ,error){
 	 
      if g.Exists(path...) {
        if s, ok := g.S(path...).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []int{},nil
          }
          var co=false
          if _, ok := s[0].(int); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want int|float64 got %T ",s[0]) 
          }
          r := make([]int, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want int|float64 got %T ",s[0]) 
            	 }
            	 r[i]=int(rs)
            }else{ 
            	 r[i],ok = V.(int)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want int got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.S(path...).Data().([]int); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }
func (g *Container) MustGetIntSliceP(path string)([]int){
	if s,e:=g.GetIntSliceP(path);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetIntSliceP(path string) ([]int ,error){
 	 	 
      if g.ExistsP(path) {
        if s, ok := g.Path(path).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []int{},nil
          }
          var co=false
          if _, ok := s[0].(int); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want int|float64 got %T ",s[0]) 
          }
          r := make([]int, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want int|float64 got %T ",s[0]) 
            	 }
            	 r[i]=int(rs)
            }else{ 
            	 r[i],ok = V.(int)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want int got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.Path(path).Data().([]int); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }


func (g *Container) MustGetInt8(path ...string)(int8 ){
	if s,e:=g.GetInt8(path ...);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetInt8(path ...string)(int8,error ){
	
    if g.Exists(path...) {
      if d, ok := g.S(path...).Data().(int8); ok {
        return d,nil
      }else if d,ok:=g.S(path...).Data().(float64);ok {
      		return int8(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want int8|float64 got %T ",g.S(path...).Data())
    }
    return 0,ErrInvalidPath
  }
func (g *Container) MustGetInt8P(path string)(int8 ){
	if s,e:=g.GetInt8P(path);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetInt8P(path string) (int8 ,error ) {
	
    if g.ExistsP(path) {
      if d, ok := g.Path(path).Data().(int8); ok {
        return d,nil
      }else if d,ok:=g.Path(path).Data().(float64); ok {
      		return int8(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want int8|float64 got %T ",g.Path(path).Data())
    }
    return 0,ErrInvalidPath
}
func (g *Container) MustGetInt8Slice(path ...string)([]int8){
	if s,e:=g.GetInt8Slice(path...);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetInt8Slice(path ...string) ([]int8 ,error){
 	 
      if g.Exists(path...) {
        if s, ok := g.S(path...).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []int8{},nil
          }
          var co=false
          if _, ok := s[0].(int8); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want int8|float64 got %T ",s[0]) 
          }
          r := make([]int8, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want int8|float64 got %T ",s[0]) 
            	 }
            	 r[i]=int8(rs)
            }else{ 
            	 r[i],ok = V.(int8)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want int8 got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.S(path...).Data().([]int8); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }
func (g *Container) MustGetInt8SliceP(path string)([]int8){
	if s,e:=g.GetInt8SliceP(path);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetInt8SliceP(path string) ([]int8 ,error){
 	 	 
      if g.ExistsP(path) {
        if s, ok := g.Path(path).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []int8{},nil
          }
          var co=false
          if _, ok := s[0].(int8); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want int8|float64 got %T ",s[0]) 
          }
          r := make([]int8, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want int8|float64 got %T ",s[0]) 
            	 }
            	 r[i]=int8(rs)
            }else{ 
            	 r[i],ok = V.(int8)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want int8 got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.Path(path).Data().([]int8); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }


func (g *Container) MustGetInt16(path ...string)(int16 ){
	if s,e:=g.GetInt16(path ...);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetInt16(path ...string)(int16,error ){
	
    if g.Exists(path...) {
      if d, ok := g.S(path...).Data().(int16); ok {
        return d,nil
      }else if d,ok:=g.S(path...).Data().(float64);ok {
      		return int16(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want int16|float64 got %T ",g.S(path...).Data())
    }
    return 0,ErrInvalidPath
  }
func (g *Container) MustGetInt16P(path string)(int16 ){
	if s,e:=g.GetInt16P(path);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetInt16P(path string) (int16 ,error ) {
	
    if g.ExistsP(path) {
      if d, ok := g.Path(path).Data().(int16); ok {
        return d,nil
      }else if d,ok:=g.Path(path).Data().(float64); ok {
      		return int16(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want int16|float64 got %T ",g.Path(path).Data())
    }
    return 0,ErrInvalidPath
}
func (g *Container) MustGetInt16Slice(path ...string)([]int16){
	if s,e:=g.GetInt16Slice(path...);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetInt16Slice(path ...string) ([]int16 ,error){
 	 
      if g.Exists(path...) {
        if s, ok := g.S(path...).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []int16{},nil
          }
          var co=false
          if _, ok := s[0].(int16); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want int16|float64 got %T ",s[0]) 
          }
          r := make([]int16, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want int16|float64 got %T ",s[0]) 
            	 }
            	 r[i]=int16(rs)
            }else{ 
            	 r[i],ok = V.(int16)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want int16 got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.S(path...).Data().([]int16); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }
func (g *Container) MustGetInt16SliceP(path string)([]int16){
	if s,e:=g.GetInt16SliceP(path);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetInt16SliceP(path string) ([]int16 ,error){
 	 	 
      if g.ExistsP(path) {
        if s, ok := g.Path(path).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []int16{},nil
          }
          var co=false
          if _, ok := s[0].(int16); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want int16|float64 got %T ",s[0]) 
          }
          r := make([]int16, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want int16|float64 got %T ",s[0]) 
            	 }
            	 r[i]=int16(rs)
            }else{ 
            	 r[i],ok = V.(int16)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want int16 got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.Path(path).Data().([]int16); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }


func (g *Container) MustGetInt32(path ...string)(int32 ){
	if s,e:=g.GetInt32(path ...);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetInt32(path ...string)(int32,error ){
	
    if g.Exists(path...) {
      if d, ok := g.S(path...).Data().(int32); ok {
        return d,nil
      }else if d,ok:=g.S(path...).Data().(float64);ok {
      		return int32(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want int32|float64 got %T ",g.S(path...).Data())
    }
    return 0,ErrInvalidPath
  }
func (g *Container) MustGetInt32P(path string)(int32 ){
	if s,e:=g.GetInt32P(path);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetInt32P(path string) (int32 ,error ) {
	
    if g.ExistsP(path) {
      if d, ok := g.Path(path).Data().(int32); ok {
        return d,nil
      }else if d,ok:=g.Path(path).Data().(float64); ok {
      		return int32(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want int32|float64 got %T ",g.Path(path).Data())
    }
    return 0,ErrInvalidPath
}
func (g *Container) MustGetInt32Slice(path ...string)([]int32){
	if s,e:=g.GetInt32Slice(path...);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetInt32Slice(path ...string) ([]int32 ,error){
 	 
      if g.Exists(path...) {
        if s, ok := g.S(path...).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []int32{},nil
          }
          var co=false
          if _, ok := s[0].(int32); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want int32|float64 got %T ",s[0]) 
          }
          r := make([]int32, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want int32|float64 got %T ",s[0]) 
            	 }
            	 r[i]=int32(rs)
            }else{ 
            	 r[i],ok = V.(int32)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want int32 got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.S(path...).Data().([]int32); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }
func (g *Container) MustGetInt32SliceP(path string)([]int32){
	if s,e:=g.GetInt32SliceP(path);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetInt32SliceP(path string) ([]int32 ,error){
 	 	 
      if g.ExistsP(path) {
        if s, ok := g.Path(path).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []int32{},nil
          }
          var co=false
          if _, ok := s[0].(int32); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want int32|float64 got %T ",s[0]) 
          }
          r := make([]int32, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want int32|float64 got %T ",s[0]) 
            	 }
            	 r[i]=int32(rs)
            }else{ 
            	 r[i],ok = V.(int32)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want int32 got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.Path(path).Data().([]int32); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }


func (g *Container) MustGetInt64(path ...string)(int64 ){
	if s,e:=g.GetInt64(path ...);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetInt64(path ...string)(int64,error ){
	
    if g.Exists(path...) {
      if d, ok := g.S(path...).Data().(int64); ok {
        return d,nil
      }else if d,ok:=g.S(path...).Data().(float64);ok {
      		return int64(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want int64|float64 got %T ",g.S(path...).Data())
    }
    return 0,ErrInvalidPath
  }
func (g *Container) MustGetInt64P(path string)(int64 ){
	if s,e:=g.GetInt64P(path);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetInt64P(path string) (int64 ,error ) {
	
    if g.ExistsP(path) {
      if d, ok := g.Path(path).Data().(int64); ok {
        return d,nil
      }else if d,ok:=g.Path(path).Data().(float64); ok {
      		return int64(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want int64|float64 got %T ",g.Path(path).Data())
    }
    return 0,ErrInvalidPath
}
func (g *Container) MustGetInt64Slice(path ...string)([]int64){
	if s,e:=g.GetInt64Slice(path...);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetInt64Slice(path ...string) ([]int64 ,error){
 	 
      if g.Exists(path...) {
        if s, ok := g.S(path...).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []int64{},nil
          }
          var co=false
          if _, ok := s[0].(int64); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want int64|float64 got %T ",s[0]) 
          }
          r := make([]int64, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want int64|float64 got %T ",s[0]) 
            	 }
            	 r[i]=int64(rs)
            }else{ 
            	 r[i],ok = V.(int64)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want int64 got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.S(path...).Data().([]int64); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }
func (g *Container) MustGetInt64SliceP(path string)([]int64){
	if s,e:=g.GetInt64SliceP(path);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetInt64SliceP(path string) ([]int64 ,error){
 	 	 
      if g.ExistsP(path) {
        if s, ok := g.Path(path).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []int64{},nil
          }
          var co=false
          if _, ok := s[0].(int64); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want int64|float64 got %T ",s[0]) 
          }
          r := make([]int64, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want int64|float64 got %T ",s[0]) 
            	 }
            	 r[i]=int64(rs)
            }else{ 
            	 r[i],ok = V.(int64)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want int64 got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.Path(path).Data().([]int64); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }


func (g *Container) MustGetUint(path ...string)(uint ){
	if s,e:=g.GetUint(path ...);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetUint(path ...string)(uint,error ){
	
    if g.Exists(path...) {
      if d, ok := g.S(path...).Data().(uint); ok {
        return d,nil
      }else if d,ok:=g.S(path...).Data().(float64);ok {
      		return uint(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want uint|float64 got %T ",g.S(path...).Data())
    }
    return 0,ErrInvalidPath
  }
func (g *Container) MustGetUintP(path string)(uint ){
	if s,e:=g.GetUintP(path);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetUintP(path string) (uint ,error ) {
	
    if g.ExistsP(path) {
      if d, ok := g.Path(path).Data().(uint); ok {
        return d,nil
      }else if d,ok:=g.Path(path).Data().(float64); ok {
      		return uint(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want uint|float64 got %T ",g.Path(path).Data())
    }
    return 0,ErrInvalidPath
}
func (g *Container) MustGetUintSlice(path ...string)([]uint){
	if s,e:=g.GetUintSlice(path...);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetUintSlice(path ...string) ([]uint ,error){
 	 
      if g.Exists(path...) {
        if s, ok := g.S(path...).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []uint{},nil
          }
          var co=false
          if _, ok := s[0].(uint); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want uint|float64 got %T ",s[0]) 
          }
          r := make([]uint, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want uint|float64 got %T ",s[0]) 
            	 }
            	 r[i]=uint(rs)
            }else{ 
            	 r[i],ok = V.(uint)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want uint got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.S(path...).Data().([]uint); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }
func (g *Container) MustGetUintSliceP(path string)([]uint){
	if s,e:=g.GetUintSliceP(path);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetUintSliceP(path string) ([]uint ,error){
 	 	 
      if g.ExistsP(path) {
        if s, ok := g.Path(path).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []uint{},nil
          }
          var co=false
          if _, ok := s[0].(uint); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want uint|float64 got %T ",s[0]) 
          }
          r := make([]uint, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want uint|float64 got %T ",s[0]) 
            	 }
            	 r[i]=uint(rs)
            }else{ 
            	 r[i],ok = V.(uint)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want uint got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.Path(path).Data().([]uint); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }


func (g *Container) MustGetUint8(path ...string)(uint8 ){
	if s,e:=g.GetUint8(path ...);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetUint8(path ...string)(uint8,error ){
	
    if g.Exists(path...) {
      if d, ok := g.S(path...).Data().(uint8); ok {
        return d,nil
      }else if d,ok:=g.S(path...).Data().(float64);ok {
      		return uint8(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want uint8|float64 got %T ",g.S(path...).Data())
    }
    return 0,ErrInvalidPath
  }
func (g *Container) MustGetUint8P(path string)(uint8 ){
	if s,e:=g.GetUint8P(path);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetUint8P(path string) (uint8 ,error ) {
	
    if g.ExistsP(path) {
      if d, ok := g.Path(path).Data().(uint8); ok {
        return d,nil
      }else if d,ok:=g.Path(path).Data().(float64); ok {
      		return uint8(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want uint8|float64 got %T ",g.Path(path).Data())
    }
    return 0,ErrInvalidPath
}
func (g *Container) MustGetUint8Slice(path ...string)([]uint8){
	if s,e:=g.GetUint8Slice(path...);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetUint8Slice(path ...string) ([]uint8 ,error){
 	 
      if g.Exists(path...) {
        if s, ok := g.S(path...).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []uint8{},nil
          }
          var co=false
          if _, ok := s[0].(uint8); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want uint8|float64 got %T ",s[0]) 
          }
          r := make([]uint8, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want uint8|float64 got %T ",s[0]) 
            	 }
            	 r[i]=uint8(rs)
            }else{ 
            	 r[i],ok = V.(uint8)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want uint8 got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.S(path...).Data().([]uint8); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }
func (g *Container) MustGetUint8SliceP(path string)([]uint8){
	if s,e:=g.GetUint8SliceP(path);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetUint8SliceP(path string) ([]uint8 ,error){
 	 	 
      if g.ExistsP(path) {
        if s, ok := g.Path(path).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []uint8{},nil
          }
          var co=false
          if _, ok := s[0].(uint8); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want uint8|float64 got %T ",s[0]) 
          }
          r := make([]uint8, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want uint8|float64 got %T ",s[0]) 
            	 }
            	 r[i]=uint8(rs)
            }else{ 
            	 r[i],ok = V.(uint8)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want uint8 got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.Path(path).Data().([]uint8); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }


func (g *Container) MustGetUint16(path ...string)(uint16 ){
	if s,e:=g.GetUint16(path ...);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetUint16(path ...string)(uint16,error ){
	
    if g.Exists(path...) {
      if d, ok := g.S(path...).Data().(uint16); ok {
        return d,nil
      }else if d,ok:=g.S(path...).Data().(float64);ok {
      		return uint16(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want uint16|float64 got %T ",g.S(path...).Data())
    }
    return 0,ErrInvalidPath
  }
func (g *Container) MustGetUint16P(path string)(uint16 ){
	if s,e:=g.GetUint16P(path);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetUint16P(path string) (uint16 ,error ) {
	
    if g.ExistsP(path) {
      if d, ok := g.Path(path).Data().(uint16); ok {
        return d,nil
      }else if d,ok:=g.Path(path).Data().(float64); ok {
      		return uint16(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want uint16|float64 got %T ",g.Path(path).Data())
    }
    return 0,ErrInvalidPath
}
func (g *Container) MustGetUint16Slice(path ...string)([]uint16){
	if s,e:=g.GetUint16Slice(path...);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetUint16Slice(path ...string) ([]uint16 ,error){
 	 
      if g.Exists(path...) {
        if s, ok := g.S(path...).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []uint16{},nil
          }
          var co=false
          if _, ok := s[0].(uint16); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want uint16|float64 got %T ",s[0]) 
          }
          r := make([]uint16, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want uint16|float64 got %T ",s[0]) 
            	 }
            	 r[i]=uint16(rs)
            }else{ 
            	 r[i],ok = V.(uint16)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want uint16 got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.S(path...).Data().([]uint16); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }
func (g *Container) MustGetUint16SliceP(path string)([]uint16){
	if s,e:=g.GetUint16SliceP(path);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetUint16SliceP(path string) ([]uint16 ,error){
 	 	 
      if g.ExistsP(path) {
        if s, ok := g.Path(path).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []uint16{},nil
          }
          var co=false
          if _, ok := s[0].(uint16); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want uint16|float64 got %T ",s[0]) 
          }
          r := make([]uint16, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want uint16|float64 got %T ",s[0]) 
            	 }
            	 r[i]=uint16(rs)
            }else{ 
            	 r[i],ok = V.(uint16)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want uint16 got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.Path(path).Data().([]uint16); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }


func (g *Container) MustGetUint32(path ...string)(uint32 ){
	if s,e:=g.GetUint32(path ...);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetUint32(path ...string)(uint32,error ){
	
    if g.Exists(path...) {
      if d, ok := g.S(path...).Data().(uint32); ok {
        return d,nil
      }else if d,ok:=g.S(path...).Data().(float64);ok {
      		return uint32(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want uint32|float64 got %T ",g.S(path...).Data())
    }
    return 0,ErrInvalidPath
  }
func (g *Container) MustGetUint32P(path string)(uint32 ){
	if s,e:=g.GetUint32P(path);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetUint32P(path string) (uint32 ,error ) {
	
    if g.ExistsP(path) {
      if d, ok := g.Path(path).Data().(uint32); ok {
        return d,nil
      }else if d,ok:=g.Path(path).Data().(float64); ok {
      		return uint32(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want uint32|float64 got %T ",g.Path(path).Data())
    }
    return 0,ErrInvalidPath
}
func (g *Container) MustGetUint32Slice(path ...string)([]uint32){
	if s,e:=g.GetUint32Slice(path...);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetUint32Slice(path ...string) ([]uint32 ,error){
 	 
      if g.Exists(path...) {
        if s, ok := g.S(path...).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []uint32{},nil
          }
          var co=false
          if _, ok := s[0].(uint32); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want uint32|float64 got %T ",s[0]) 
          }
          r := make([]uint32, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want uint32|float64 got %T ",s[0]) 
            	 }
            	 r[i]=uint32(rs)
            }else{ 
            	 r[i],ok = V.(uint32)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want uint32 got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.S(path...).Data().([]uint32); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }
func (g *Container) MustGetUint32SliceP(path string)([]uint32){
	if s,e:=g.GetUint32SliceP(path);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetUint32SliceP(path string) ([]uint32 ,error){
 	 	 
      if g.ExistsP(path) {
        if s, ok := g.Path(path).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []uint32{},nil
          }
          var co=false
          if _, ok := s[0].(uint32); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want uint32|float64 got %T ",s[0]) 
          }
          r := make([]uint32, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want uint32|float64 got %T ",s[0]) 
            	 }
            	 r[i]=uint32(rs)
            }else{ 
            	 r[i],ok = V.(uint32)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want uint32 got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.Path(path).Data().([]uint32); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }


func (g *Container) MustGetUint64(path ...string)(uint64 ){
	if s,e:=g.GetUint64(path ...);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetUint64(path ...string)(uint64,error ){
	
    if g.Exists(path...) {
      if d, ok := g.S(path...).Data().(uint64); ok {
        return d,nil
      }else if d,ok:=g.S(path...).Data().(float64);ok {
      		return uint64(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want uint64|float64 got %T ",g.S(path...).Data())
    }
    return 0,ErrInvalidPath
  }
func (g *Container) MustGetUint64P(path string)(uint64 ){
	if s,e:=g.GetUint64P(path);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetUint64P(path string) (uint64 ,error ) {
	
    if g.ExistsP(path) {
      if d, ok := g.Path(path).Data().(uint64); ok {
        return d,nil
      }else if d,ok:=g.Path(path).Data().(float64); ok {
      		return uint64(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want uint64|float64 got %T ",g.Path(path).Data())
    }
    return 0,ErrInvalidPath
}
func (g *Container) MustGetUint64Slice(path ...string)([]uint64){
	if s,e:=g.GetUint64Slice(path...);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetUint64Slice(path ...string) ([]uint64 ,error){
 	 
      if g.Exists(path...) {
        if s, ok := g.S(path...).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []uint64{},nil
          }
          var co=false
          if _, ok := s[0].(uint64); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want uint64|float64 got %T ",s[0]) 
          }
          r := make([]uint64, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want uint64|float64 got %T ",s[0]) 
            	 }
            	 r[i]=uint64(rs)
            }else{ 
            	 r[i],ok = V.(uint64)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want uint64 got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.S(path...).Data().([]uint64); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }
func (g *Container) MustGetUint64SliceP(path string)([]uint64){
	if s,e:=g.GetUint64SliceP(path);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetUint64SliceP(path string) ([]uint64 ,error){
 	 	 
      if g.ExistsP(path) {
        if s, ok := g.Path(path).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []uint64{},nil
          }
          var co=false
          if _, ok := s[0].(uint64); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want uint64|float64 got %T ",s[0]) 
          }
          r := make([]uint64, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want uint64|float64 got %T ",s[0]) 
            	 }
            	 r[i]=uint64(rs)
            }else{ 
            	 r[i],ok = V.(uint64)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want uint64 got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.Path(path).Data().([]uint64); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }


func (g *Container) MustGetFloat32(path ...string)(float32 ){
	if s,e:=g.GetFloat32(path ...);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetFloat32(path ...string)(float32,error ){
	
    if g.Exists(path...) {
      if d, ok := g.S(path...).Data().(float32); ok {
        return d,nil
      }else if d,ok:=g.S(path...).Data().(float64);ok {
      		return float32(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want float32|float64 got %T ",g.S(path...).Data())
    }
    return 0,ErrInvalidPath
  }
func (g *Container) MustGetFloat32P(path string)(float32 ){
	if s,e:=g.GetFloat32P(path);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetFloat32P(path string) (float32 ,error ) {
	
    if g.ExistsP(path) {
      if d, ok := g.Path(path).Data().(float32); ok {
        return d,nil
      }else if d,ok:=g.Path(path).Data().(float64); ok {
      		return float32(d),nil
      	}
      return 0,fmt.Errorf("Type Not Match: want float32|float64 got %T ",g.Path(path).Data())
    }
    return 0,ErrInvalidPath
}
func (g *Container) MustGetFloat32Slice(path ...string)([]float32){
	if s,e:=g.GetFloat32Slice(path...);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetFloat32Slice(path ...string) ([]float32 ,error){
 	 
      if g.Exists(path...) {
        if s, ok := g.S(path...).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []float32{},nil
          }
          var co=false
          if _, ok := s[0].(float32); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want float32|float64 got %T ",s[0]) 
          }
          r := make([]float32, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want float32|float64 got %T ",s[0]) 
            	 }
            	 r[i]=float32(rs)
            }else{ 
            	 r[i],ok = V.(float32)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want float32 got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.S(path...).Data().([]float32); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }
func (g *Container) MustGetFloat32SliceP(path string)([]float32){
	if s,e:=g.GetFloat32SliceP(path);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetFloat32SliceP(path string) ([]float32 ,error){
 	 	 
      if g.ExistsP(path) {
        if s, ok := g.Path(path).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []float32{},nil
          }
          var co=false
          if _, ok := s[0].(float32); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want float32|float64 got %T ",s[0]) 
          }
          r := make([]float32, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want float32|float64 got %T ",s[0]) 
            	 }
            	 r[i]=float32(rs)
            }else{ 
            	 r[i],ok = V.(float32)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want float32 got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.Path(path).Data().([]float32); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }


func (g *Container) MustGetFloat64(path ...string)(float64 ){
	if s,e:=g.GetFloat64(path ...);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetFloat64(path ...string)(float64,error ){
	
    if g.Exists(path...) {
      if d, ok := g.S(path...).Data().(float64); ok {
        return d,nil
      }
      return 0,fmt.Errorf("Type Not Match: want float64 got %T ",g.S(path...).Data())
    }
    return 0,ErrInvalidPath
  }
func (g *Container) MustGetFloat64P(path string)(float64 ){
	if s,e:=g.GetFloat64P(path);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetFloat64P(path string) (float64 ,error ) {
	
    if g.ExistsP(path) {
      if d, ok := g.Path(path).Data().(float64); ok {
        return d,nil
      }
      return 0,fmt.Errorf("Type Not Match: want float64| got %T ",g.Path(path).Data())
    }
    return 0,ErrInvalidPath
}
func (g *Container) MustGetFloat64Slice(path ...string)([]float64){
	if s,e:=g.GetFloat64Slice(path...);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetFloat64Slice(path ...string) ([]float64 ,error){
 	 
      if g.Exists(path...) {
        if s, ok := g.S(path...).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []float64{},nil
          }
          
          if _, ok := s[0].(float64); !ok {
              return nil,fmt.Errorf("Type Not Match: want float64 got %T ",s[0]) 
          }
          r := make([]float64, len(s))
          for i, V := range s {
           
            	 r[i],ok = V.(float64)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want float64 got %T ",V)
            	 }
              
          }
          return r,nil
        }else if s, ok := g.S(path...).Data().([]float64); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }
func (g *Container) MustGetFloat64SliceP(path string)([]float64){
	if s,e:=g.GetFloat64SliceP(path);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetFloat64SliceP(path string) ([]float64 ,error){
 	 	 
      if g.ExistsP(path) {
        if s, ok := g.Path(path).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []float64{},nil
          }
          
          if _, ok := s[0].(float64); !ok {
              return nil,fmt.Errorf("Type Not Match: want float64 got %T ",s[0]) 
          }
          r := make([]float64, len(s))
          for i, V := range s {
           
            	 r[i],ok = V.(float64)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want float64 got %T ",V)
            	 }
              
          }
          return r,nil
        }else if s, ok := g.Path(path).Data().([]float64); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }


func (g *Container) MustGetString(path ...string)(string ){
	if s,e:=g.GetString(path ...);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetString(path ...string)(string,error ){
	
    if g.Exists(path...) {
      if d, ok := g.S(path...).Data().(string); ok {
        return d,nil
      }else if d,ok:=g.S(path...).Data().([]byte);ok {
      		return string(d),nil
      	}
      return ``,fmt.Errorf("Type Not Match: want string|[]byte got %T ",g.S(path...).Data())
    }
    return ``,ErrInvalidPath
  }
func (g *Container) MustGetStringP(path string)(string ){
	if s,e:=g.GetStringP(path);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetStringP(path string) (string ,error ) {
	
    if g.ExistsP(path) {
      if d, ok := g.Path(path).Data().(string); ok {
        return d,nil
      }else if d,ok:=g.Path(path).Data().([]byte); ok {
      		return string(d),nil
      	}
      return ``,fmt.Errorf("Type Not Match: want string|[]byte got %T ",g.Path(path).Data())
    }
    return ``,ErrInvalidPath
}
func (g *Container) MustGetStringSlice(path ...string)([]string){
	if s,e:=g.GetStringSlice(path...);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetStringSlice(path ...string) ([]string ,error){
 	 
      if g.Exists(path...) {
        if s, ok := g.S(path...).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []string{},nil
          }
          var co=false
          if _, ok := s[0].(string); !ok {
             co=true
          }else if _,ok:= s[0].([]byte); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want string|[]byte got %T ",s[0]) 
          }
          r := make([]string, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.([]byte)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want string|[]byte got %T ",s[0]) 
            	 }
            	 r[i]=string(rs)
            }else{ 
            	 r[i],ok = V.(string)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want string got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.S(path...).Data().([]string); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }
func (g *Container) MustGetStringSliceP(path string)([]string){
	if s,e:=g.GetStringSliceP(path);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetStringSliceP(path string) ([]string ,error){
 	 	 
      if g.ExistsP(path) {
        if s, ok := g.Path(path).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []string{},nil
          }
          var co=false
          if _, ok := s[0].(string); !ok {
             co=true
          }else if _,ok:= s[0].([]byte); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want string|[]byte got %T ",s[0]) 
          }
          r := make([]string, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.([]byte)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want string|[]byte got %T ",s[0]) 
            	 }
            	 r[i]=string(rs)
            }else{ 
            	 r[i],ok = V.(string)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want string got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.Path(path).Data().([]string); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }


func (g *Container) MustGetByteSlice(path ...string)([]byte){
	if s,e:=g.GetByteSlice(path...);e!=nil{
		panic(e)
	}else{return s}
}
 func (g *Container) GetByteSlice(path ...string) ([]byte ,error){
 	 if  r,e:=g.GetUint8Slice(path...);e==nil{
 	 	  rx := make([]byte, len(r))
 	 	for i,r1:=range r{
 	 		rx[i]=byte(r1)
 	 	}
 	 	return rx,nil
 	 }
      if g.Exists(path...) {
        if s, ok := g.S(path...).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []byte{},nil
          }
          var co=false
          if _, ok := s[0].(byte); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want byte|float64 got %T ",s[0]) 
          }
          r := make([]byte, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want byte|float64 got %T ",s[0]) 
            	 }
            	 r[i]=byte(rs)
            }else{ 
            	 r[i],ok = V.(byte)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want byte got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.S(path...).Data().([]byte); ok {        	 
        	return s,nil
        }else if s, ok := g.S(path...).Data().([]uint8); ok {
        	  r := make([]byte, len(s))
          		for i, V := range s { 
            	 r[i]=byte(V)
            }          
        	return r,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }
func (g *Container) MustGetByteSliceP(path string)([]byte){
	if s,e:=g.GetByteSliceP(path);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetByteSliceP(path string) ([]byte ,error){
 	 	 if  r,e:=g.GetUint8SliceP(path);e==nil{
 	 	  rx := make([]byte, len(r))
 	 	for i,r1:=range r{
 	 		rx[i]=byte(r1)
 	 	}
 	 	return rx,nil
 	 }
      if g.ExistsP(path) {
        if s, ok := g.Path(path).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []byte{},nil
          }
          var co=false
          if _, ok := s[0].(byte); !ok {
             co=true
          }else if _,ok:= s[0].(float64); co&&!ok {
             return nil,fmt.Errorf("Type Not Match: want byte|float64 got %T ",s[0]) 
          }
          r := make([]byte, len(s))
          for i, V := range s {
            if co{
            	 rs,ok := V.(float64)
            	 if !ok{
            	 	return nil,fmt.Errorf("Type Not Match: want byte|float64 got %T ",s[0]) 
            	 }
            	 r[i]=byte(rs)
            }else{ 
            	 r[i],ok = V.(byte)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want byte got %T ",V)
            	 }
             }   
          }
          return r,nil
        }else if s, ok := g.Path(path).Data().([]byte); ok {        	 
        	return s,nil
        }else if s, ok := g.Path(path).Data().([]uint8); ok {
        	  r := make([]byte, len(s))
          		for i, V := range s { 
            	 r[i]=byte(V)
            }          
        	return r,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }


func (g *Container) MustGetBool(path ...string)(bool ){
	if s,e:=g.GetBool(path ...);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetBool(path ...string)(bool,error ){
	
    if g.Exists(path...) {
      if d, ok := g.S(path...).Data().(bool); ok {
        return d,nil
      }
      return false,fmt.Errorf("Type Not Match: want bool got %T ",g.S(path...).Data())
    }
    return false,ErrInvalidPath
  }
func (g *Container) MustGetBoolP(path string)(bool ){
	if s,e:=g.GetBoolP(path);e!=nil{panic(e)}else{return s}
}
func (g *Container) GetBoolP(path string) (bool ,error ) {
	
    if g.ExistsP(path) {
      if d, ok := g.Path(path).Data().(bool); ok {
        return d,nil
      }
      return false,fmt.Errorf("Type Not Match: want bool| got %T ",g.Path(path).Data())
    }
    return false,ErrInvalidPath
}
func (g *Container) MustGetBoolSlice(path ...string)([]bool){
	if s,e:=g.GetBoolSlice(path...);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetBoolSlice(path ...string) ([]bool ,error){
 	 
      if g.Exists(path...) {
        if s, ok := g.S(path...).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []bool{},nil
          }
          
          if _, ok := s[0].(bool); !ok {
              return nil,fmt.Errorf("Type Not Match: want bool got %T ",s[0]) 
          }
          r := make([]bool, len(s))
          for i, V := range s {
           
            	 r[i],ok = V.(bool)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want bool got %T ",V)
            	 }
              
          }
          return r,nil
        }else if s, ok := g.S(path...).Data().([]bool); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }
func (g *Container) MustGetBoolSliceP(path string)([]bool){
	if s,e:=g.GetBoolSliceP(path);e!=nil{panic(e)}else{return s}
}
 func (g *Container) GetBoolSliceP(path string) ([]bool ,error){
 	 	 
      if g.ExistsP(path) {
        if s, ok := g.Path(path).Data().([]interface{}); ok {
          if len(s) == 0 {
            return []bool{},nil
          }
          
          if _, ok := s[0].(bool); !ok {
              return nil,fmt.Errorf("Type Not Match: want bool got %T ",s[0]) 
          }
          r := make([]bool, len(s))
          for i, V := range s {
           
            	 r[i],ok = V.(bool)
            	  if !ok{
              		return nil,fmt.Errorf("Type Not Match: want bool got %T ",V)
            	 }
              
          }
          return r,nil
        }else if s, ok := g.Path(path).Data().([]bool); ok {        	 
        	return s,nil
        }
        return nil,ErrNotArray
      }
      return nil,ErrInvalidPath
    }
